"""
Base Classes for Agentic Architecture
=====================================
Defines core types, state management, and base interfaces for the planner-based agent system.
"""

import logging
from dataclasses import dataclass, field
from typing import Dict, List, Any, Optional, Callable, Union
from enum import Enum
from datetime import datetime

logger = logging.getLogger(__name__)


class ToolCategory(Enum):
    """Categories of available tools"""
    RAG = "rag"                  # Document retrieval and Q&A
    SQL = "sql"                  # Data queries
    ML = "ml"                    # Machine learning operations
    VISUALIZATION = "viz"       # Chart generation
    UTILITY = "utility"         # Helper operations


class StepStatus(Enum):
    """Status of an execution step"""
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    SKIPPED = "skipped"


@dataclass
class Tool:
    """
    Represents a callable tool in the agent system.
    
    Attributes:
        name: Unique identifier for the tool
        description: Human-readable description for the planner
        category: Type of tool (RAG, SQL, ML, etc.)
        function: The actual callable to execute
        parameters: Dict describing expected parameters
        returns: Dict describing return value schema
        requires_data: Whether tool requires data to be uploaded first
        requires_model: Whether tool requires a trained model
    """
    name: str
    description: str
    category: ToolCategory
    function: Callable
    parameters: Dict[str, Any] = field(default_factory=dict)
    returns: Dict[str, Any] = field(default_factory=dict)
    requires_data: bool = False
    requires_model: bool = False
    
    def execute(self, **kwargs) -> Dict[str, Any]:
        """Execute the tool with given parameters"""
        try:
            result = self.function(**kwargs)
            return {
                "success": True,
                "tool": self.name,
                "result": result
            }
        except Exception as e:
            logger.error(f"Tool {self.name} execution failed: {e}")
            return {
                "success": False,
                "tool": self.name,
                "error": str(e)
            }
    
    def to_prompt_description(self) -> str:
        """Generate description for planner prompt"""
        params_str = ", ".join([f"{k}: {v}" for k, v in self.parameters.items()])
        return f"- {self.name}: {self.description} | Parameters: ({params_str})"


@dataclass 
class ExecutionStep:
    """
    A single step in an execution plan.
    
    Attributes:
        step_id: Unique identifier
        tool_name: Name of tool to execute
        description: What this step accomplishes
        parameters: Parameters to pass to the tool
        depends_on: List of step_ids this step depends on
        status: Current status of the step
        result: Output from tool execution
        error: Error message if failed
        started_at: When execution started
        completed_at: When execution finished
    """
    step_id: int
    tool_name: str
    description: str
    parameters: Dict[str, Any] = field(default_factory=dict)
    depends_on: List[int] = field(default_factory=list)
    status: StepStatus = StepStatus.PENDING
    result: Optional[Dict[str, Any]] = None
    error: Optional[str] = None
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization"""
        return {
            "step_id": self.step_id,
            "tool_name": self.tool_name,
            "description": self.description,
            "parameters": self.parameters,
            "depends_on": self.depends_on,
            "status": self.status.value,
            "result": self.result,
            "error": self.error,
            "started_at": self.started_at.isoformat() if self.started_at else None,
            "completed_at": self.completed_at.isoformat() if self.completed_at else None
        }


@dataclass
class ExecutionPlan:
    """
    A complete execution plan generated by the planner.
    
    Attributes:
        goal: The user's original goal/query
        steps: Ordered list of execution steps
        reasoning: Planner's reasoning for this plan
        estimated_tools: List of tools that will be used
        created_at: When plan was created
    """
    goal: str
    steps: List[ExecutionStep]
    reasoning: str = ""
    estimated_tools: List[str] = field(default_factory=list)
    created_at: datetime = field(default_factory=datetime.now)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization"""
        return {
            "goal": self.goal,
            "steps": [step.to_dict() for step in self.steps],
            "reasoning": self.reasoning,
            "estimated_tools": self.estimated_tools,
            "created_at": self.created_at.isoformat()
        }
    
    def get_pending_steps(self) -> List[ExecutionStep]:
        """Get all pending steps that can be executed"""
        pending = []
        completed_ids = {s.step_id for s in self.steps if s.status == StepStatus.COMPLETED}
        
        for step in self.steps:
            if step.status == StepStatus.PENDING:
                # Check if all dependencies are met
                if all(dep_id in completed_ids for dep_id in step.depends_on):
                    pending.append(step)
        
        return pending
    
    def is_complete(self) -> bool:
        """Check if all steps are completed or failed"""
        return all(
            step.status in [StepStatus.COMPLETED, StepStatus.FAILED, StepStatus.SKIPPED]
            for step in self.steps
        )
    
    def get_progress(self) -> Dict[str, int]:
        """Get execution progress statistics"""
        statuses = {}
        for step in self.steps:
            status = step.status.value
            statuses[status] = statuses.get(status, 0) + 1
        return statuses


@dataclass
class AgentState:
    """
    Maintains state throughout agent execution.
    
    This is the central state object that tracks all intermediate results,
    allowing for stateful multi-step reasoning.
    
    Attributes:
        goal: Original user goal
        plan: Current execution plan
        documents: Retrieved document chunks
        sql_results: Results from SQL queries
        model_metrics: ML model training metrics
        predictions: ML predictions
        charts: Generated chart data (base64)
        insights: Accumulated insights
        errors: Any errors encountered
        context: Additional context (schema, stats, etc.)
        started_at: When agent started
        completed_at: When agent finished
    """
    goal: str
    plan: Optional[ExecutionPlan] = None
    
    # Accumulated results from tools
    documents: List[Dict[str, Any]] = field(default_factory=list)
    sql_results: List[Dict[str, Any]] = field(default_factory=list)
    model_metrics: Optional[Dict[str, Any]] = None
    predictions: List[Dict[str, Any]] = field(default_factory=list)
    charts: List[str] = field(default_factory=list)
    insights: List[str] = field(default_factory=list)
    
    # Error tracking
    errors: List[str] = field(default_factory=list)
    
    # Context
    context: Dict[str, Any] = field(default_factory=dict)
    
    # Timing
    started_at: datetime = field(default_factory=datetime.now)
    completed_at: Optional[datetime] = None
    
    def update_from_tool_result(self, tool_name: str, result: Dict[str, Any]):
        """Update state based on tool execution result"""
        if not result.get("success"):
            self.errors.append(f"{tool_name}: {result.get('error', 'Unknown error')}")
            return
        
        data = result.get("result", {})
        
        # Route result to appropriate state field
        if "rag" in tool_name or "document" in tool_name:
            if "chunks" in data:
                self.documents.extend(data.get("chunks", []))
            if "answer" in data:
                self.insights.append(data.get("answer", ""))
            if "sources" in data:
                self.documents.extend(data.get("sources", []))
                
        elif "sql" in tool_name or "query" in tool_name:
            if "results" in data:
                self.sql_results.append({
                    "sql": data.get("sql"),
                    "results": data.get("results"),
                    "columns": data.get("columns"),
                    "row_count": data.get("row_count")
                })
            if "answer" in data:
                self.insights.append(data.get("answer", ""))
                
        elif "train" in tool_name or "ml" in tool_name:
            if "accuracy" in data or "metrics" in data:
                self.model_metrics = data
                
        elif "predict" in tool_name:
            if "predictions" in data:
                self.predictions.extend(data.get("predictions", []))
            elif "probability" in data:
                self.predictions.append(data)
                
        elif "chart" in tool_name or "viz" in tool_name:
            if "chart" in data:
                self.charts.append(data.get("chart"))
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert state to dictionary for JSON serialization"""
        return {
            "goal": self.goal,
            "plan": self.plan.to_dict() if self.plan else None,
            "documents_count": len(self.documents),
            "sql_results_count": len(self.sql_results),
            "model_metrics": self.model_metrics,
            "predictions_count": len(self.predictions),
            "charts_count": len(self.charts),
            "insights": self.insights,
            "errors": self.errors,
            "context": self.context,
            "started_at": self.started_at.isoformat(),
            "completed_at": self.completed_at.isoformat() if self.completed_at else None
        }
    
    def get_summary(self) -> Dict[str, Any]:
        """Get a concise summary of current state"""
        return {
            "has_documents": len(self.documents) > 0,
            "has_sql_results": len(self.sql_results) > 0,
            "has_model": self.model_metrics is not None,
            "has_predictions": len(self.predictions) > 0,
            "has_charts": len(self.charts) > 0,
            "insights_count": len(self.insights),
            "errors_count": len(self.errors)
        }
